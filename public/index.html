<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åœ¨çº¿æ£‹ç±»ä¸´æ—¶è”æœºç½‘ç«™</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --board-bg: #e3c18d;
            --body-bg: #f5f7fa;
            --host-color: #f1c40f;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: var(--body-bg);
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        #setup {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        h1 {
            margin-top: 0;
            color: #333;
            font-size: 1.5rem;
        }

        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .status-card {
            background: white;
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        #canvas-wrapper {
            position: relative;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: visible;
        }

        canvas {
            background-color: var(--board-bg);
            display: block;
            border-radius: 4px;
            touch-action: none;
        }

        .side-panel {
            width: 100%;
            max-width: 600px;
            background: white;
            margin-top: 15px;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .player-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
        }

        .badge-host {
            background-color: var(--host-color);
        }

        .badge-black {
            background-color: #000;
        }

        .badge-white {
            background-color: #999;
        }

        .badge-viewer {
            background-color: #ccc;
        }

        .role-btn {
            font-size: 0.8rem;
            padding: 4px 8px;
            margin-left: 5px;
            border-radius: 6px;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            transition: transform 0.2s, background 0.3s;
        }

        button:active {
            transform: scale(0.95);
        }

        button.secondary {
            background-color: #95a5a6;
        }

        button.mini {
            padding: 5px 10px;
            font-size: 0.8rem;
            border-radius: 6px;
        }

        input {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            border: 2px solid #eee;
            border-radius: 12px;
            margin-bottom: 15px;
            box-sizing: border-box;
            outline: none;
        }

        #floating-confirm {
            position: absolute;
            display: none;
            flex-direction: row;
            gap: 8px;
            z-index: 100;
        }

        .btn-confirm {
            background-color: var(--success-color);
            padding: 8px 16px;
            border-radius: 8px;
        }

        .btn-cancel {
            background-color: var(--danger-color);
            padding: 8px 16px;
            border-radius: 8px;
        }

        .info-text {
            color: #7f8c8d;
            font-size: 0.85rem;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            canvas {
                width: 95vw !important;
                height: auto !important;
            }
        }

        /* åœ¨çº¿ç©å®¶é¢æ¿ */
        #online-players-panel {
            background: white;
            padding: 20px 24px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 400px;
            margin-top: 20px;
        }

        .online-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 14px;
        }

        .online-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .online-count-badge {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: #fff;
            font-size: 0.8rem;
            font-weight: 700;
            padding: 3px 10px;
            border-radius: 20px;
            min-width: 24px;
            text-align: center;
        }

        .online-room-group {
            background: #f8f9fb;
            border-radius: 10px;
            padding: 10px 14px;
            margin-bottom: 10px;
        }

        .online-room-title {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: #555;
        }

        .game-mode-tag {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 4px;
            color: #fff;
            font-weight: 600;
        }

        .game-mode-tag.go {
            background: #2ecc71;
        }

        .game-mode-tag.gomoku {
            background: #3498db;
        }

        .game-mode-tag.xiangqi {
            background: #e67e22;
        }

        .online-player-name {
            display: inline-block;
            background: #eef1f6;
            color: #333;
            font-size: 0.82rem;
            padding: 3px 10px;
            border-radius: 12px;
            margin: 2px 4px 2px 0;
        }

        .online-empty {
            text-align: center;
            color: #aaa;
            font-size: 0.9rem;
            padding: 14px 0;
        }

        .join-room-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            padding: 4px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s;
        }

        .join-room-btn:hover {
            opacity: 0.85;
        }

        .join-room-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .kick-btn {
            background-color: var(--danger-color);
            color: #fff;
            border: none;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            margin-left: 5px;
        }
    </style>
</head>

<body>
    <div id="setup">
        <h1>å¯¹å¼ˆå¹³å°</h1>
        <input type="text" id="usernameInput" placeholder="è¾“å…¥ç”¨æˆ·å">
        <input type="text" id="roomInput" placeholder="è¾“å…¥æˆ¿é—´å·">
        <div style="margin-bottom: 15px; text-align: left;">
            <label>æ¸¸æˆæ¨¡å¼ï¼š</label>
            <select id="gameModeSelect" onchange="toggleSizeInput()"
                style="width: 100%; padding: 10px; border-radius: 8px;">
                <option value="1">å›´æ£‹</option>
                <option value="2">äº”å­æ£‹</option>
                <option value="3">ä¸­å›½è±¡æ£‹</option>
            </select>
        </div>
        <div id="sizeInputContainer" style="margin-bottom: 15px; text-align: left;">
            <label id="sizeLabel">æ£‹ç›˜å¤§å° (9-19)ï¼š</label>
            <input type="number" id="boardSizeInput" value="15" min="9" max="19">
        </div>
        <button onclick="joinRoom()" style="width: 100%;">è¿›å…¥æˆ¿é—´</button>
    </div>

    <div id="online-players-panel">
        <div class="online-header">
            <h3>ğŸŸ¢ åœ¨çº¿ç©å®¶</h3>
            <span class="online-count-badge" id="online-count">0</span>
        </div>
        <div id="online-players-list">
            <div class="online-empty">æš‚æ— åœ¨çº¿ç©å®¶</div>
        </div>
    </div>

    <div id="game-container">
        <div id="status" class="status-card">æ­£åœ¨è¿æ¥...</div>

        <div id="canvas-wrapper">
            <canvas id="board"></canvas>
            <div id="floating-confirm">
                <button class="btn-cancel" onclick="cancelMove()">å–æ¶ˆ</button>
                <button class="btn-confirm" onclick="confirmMove()">è½å­</button>
            </div>
        </div>

        <div class="side-panel">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <strong>æˆ¿é—´å·: <span id="room-id-display">-</span></strong>
                <div style="display:flex; gap: 5px;">
                    <button class="mini secondary" onclick="undoMove()">æ‚”æ£‹</button>
                    <button class="mini secondary" onclick="surrender()">è®¤è¾“</button>
                    <button class="mini secondary" onclick="resetGame()">é‡ç½®</button>
                    <button class="mini secondary" id="passBtn" style="display:none" onclick="passMove()">åœä¸€æ‰‹</button>
                </div>
            </div>
            <ul id="player-list" class="player-list"></ul>
            <p class="info-text" id="host-hint" style="display:none; color:var(--primary-color);">æ‚¨æ˜¯æˆ¿ä¸»ï¼Œå¯ä»¥ç‚¹å‡»ç©å®¶åˆ—è¡¨è°ƒæ•´é»‘ç™½æ£‹</p>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status');
        const playerListUI = document.getElementById('player-list');
        const floatingConfirm = document.getElementById('floating-confirm');

        let currentRoom = '';
        let myId = '';
        let myRole = 0;
        let currentTurn = 1;
        let isHost = false;
        let isStarted = false;
        let gameMode = '2'; // é»˜è®¤äº”å­æ£‹ç¼–å· 2
        let boardSize = 15;
        let lastMove = null;
        let winLine = null;
        let board = [];
        let pendingMove = null;
        let selectedPiece = null; // è±¡æ£‹é€‰ä¸­æ£‹å­
        let capturedStones = { 1: 0, 2: 0 }; // å›´æ£‹æå­

        const CANVAS_SIZE = 600;
        const padding = 30;
        let cellSize = (CANVAS_SIZE - padding * 2) / 14;

        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        function toggleSizeInput() {
            const mode = document.getElementById('gameModeSelect').value;
            const container = document.getElementById('sizeInputContainer');
            container.style.display = (mode === '3') ? 'none' : 'block';
            // åˆ‡æ¢æ¨¡å¼æ—¶ï¼Œé‡ç½® roomID è¾“å…¥æ¡†çš„å€¼ä»¥é˜²ç©ºæ ¼å¹²æ‰°
            const roomInput = document.getElementById('roomInput');
            roomInput.value = roomInput.value.trim();
        }

        function joinRoom() {
            const usernameInput = document.getElementById('usernameInput');
            const roomInput = document.getElementById('roomInput');
            const modeSelect = document.getElementById('gameModeSelect');
            const sizeInput = document.getElementById('boardSizeInput');

            const username = usernameInput.value.trim();
            const roomID = roomInput.value.trim();
            const mode = modeSelect.value;
            const size = sizeInput.value;

            if (!username || !roomID) return alert('è¯·è¾“å…¥ç”¨æˆ·åå’Œæˆ¿é—´å·');

            console.log(`Attempting to join room ${roomID} with mode ${mode}`);
            // è®°å½•å½“å‰å°è¯•åŠ å…¥çš„æˆ¿é—´ IDï¼Œä½†ä¸ç«‹å³åˆ‡æ¢ç•Œé¢
            socket.emit('joinRoom', { roomID, username, gameMode: mode, boardSize: size });
        }

        socket.on('initData', (data) => {
            myId = data.myId;
            currentRoom = data.roomID;
            isHost = data.isHost;
            gameMode = String(data.gameMode); // ç¡®ä¿æ˜¯å­—ç¬¦ä¸²ç¼–å·
            boardSize = data.boardSize;
            if (gameMode === '3') {
                cellSize = (CANVAS_SIZE - padding * 2) / 8;
                canvas.height = padding * 2 + 9 * cellSize;
            } else {
                cellSize = (CANVAS_SIZE - padding * 2) / (boardSize - 1);
                canvas.height = CANVAS_SIZE;
            }
            isStarted = data.isStarted || false;
            lastMove = data.lastMove || null;

            // æˆåŠŸåŠ å…¥åæ‰åˆ‡æ¢ç•Œé¢
            document.getElementById('setup').style.display = 'none';
            document.getElementById('online-players-panel').style.display = 'none';
            document.getElementById('game-container').style.display = 'flex';
            document.getElementById('room-id-display').innerText = currentRoom;

            if (isHost) document.getElementById('host-hint').style.display = 'block';
            document.getElementById('passBtn').style.display = (gameMode === '1') ? 'inline-block' : 'none';
            updatePlayersUI(data.players);
            drawBoard();
        });

        socket.on('updatePlayers', (players) => {
            const me = players.find(p => p.id === myId);
            if (me) {
                myRole = me.role;
                isHost = me.isHost;
                document.getElementById('host-hint').style.display = isHost ? 'block' : 'none';
            }
            updatePlayersUI(players);
            updateStatus();
        });

        socket.on('updateBoard', (data) => {
            board = data.board;
            currentTurn = data.turn;
            isStarted = data.isStarted || false;
            lastMove = data.lastMove || null;
            winLine = null;
            pendingMove = null;
            selectedPiece = null;
            if (data.capturedStones) capturedStones = data.capturedStones;
            drawBoard();
            updateStatus();
        });

        socket.on('errorMsg', (msg) => {
            alert(msg);
        });

        socket.on('gameModeMismatch', (data) => {
            alert(`æ¨¡å¼é€‰æ‹©ä¸åŒ¹é…ï¼Œåº”é€‰ä¸ºï¼š${data.requiredModeName}`);
            // è‡ªåŠ¨å°†ä¸‹æ‹‰æ¡†åˆ‡æ¢åˆ°æ­£ç¡®çš„æ¨¡å¼
            document.getElementById('gameModeSelect').value = data.requiredMode;
            toggleSizeInput();
            // ç¡®ä¿åœç•™åœ¨åˆå§‹ç•Œé¢
            document.getElementById('setup').style.display = 'block';
            document.getElementById('game-container').style.display = 'none';
        });

        socket.on('resetRequested', (data) => {
            if (confirm(`${data.username} è¯·æ±‚é‡ç½®æ£‹å±€ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ`)) {
                socket.emit('confirmReset', { roomID: currentRoom, accept: true });
            } else {
                socket.emit('confirmReset', { roomID: currentRoom, accept: false });
            }
        });

        socket.on('undoRequested', (data) => {
            if (confirm(`${data.username} è¯·æ±‚æ‚”æ£‹ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ`)) {
                socket.emit('confirmUndo', { roomID: currentRoom, accept: true });
            } else {
                socket.emit('confirmUndo', { roomID: currentRoom, accept: false });
            }
        });

        socket.on('undoSuccess', () => {
            alert('æ‚”æ£‹æˆåŠŸ');
        });

        socket.on('playerPassed', (data) => {
            alert(`${data.username} é€‰æ‹©äº†åœä¸€æ‰‹(PASS)`);
        });

        socket.on('undoDeclined', () => {
            alert('å¯¹æ–¹æ‹’ç»äº†æ‚”æ£‹è¯·æ±‚');
        });

        socket.on('gameReset', (msg) => {
            isStarted = false;
            lastMove = null;
            winLine = null;
            alert(msg || 'æ¸¸æˆå·²é‡ç½®');
        });

        socket.on('resetDeclined', () => alert('å¯¹æ–¹æ‹’ç»äº†é‡ç½®è¯·æ±‚'));

        socket.on('gameOver', (data) => {
            isStarted = false;
            winLine = data.winLine || null;
            drawBoard(); // ç«‹å³é‡ç»˜ä»¥æ˜¾ç¤ºè¿ç 

            setTimeout(() => {
                lastMove = null;
                winLine = null;
                let msg;
                if (gameMode === '3') {
                    msg = `æ¸¸æˆç»“æŸï¼${data.winnerName} (${data.winner === 1 ? 'çº¢æ–¹' : 'é»‘æ–¹'}) è·èƒœï¼`;
                } else {
                    msg = `æ¸¸æˆç»“æŸï¼${data.winnerName} (${data.winner === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹'}) è·èƒœï¼`;
                }
                if (data.isSurrender) {
                    msg = `æ¸¸æˆç»“æŸï¼${data.loserName} è®¤è¾“ï¼Œ${data.winnerName} è·èƒœï¼`;
                }
                alert(msg + '\nå³å°†å¼€å§‹ä¸‹ä¸€å±€ï¼ŒåŒæ–¹è§’è‰²å°†è‡ªåŠ¨è°ƒæ¢ã€‚');
            }, 3000); // å»¶è¿Ÿ 3 ç§’å¼¹å‡ºæç¤º
        });

        function updatePlayersUI(players) {
            playerListUI.innerHTML = '';
            players.forEach(p => {
                const li = document.createElement('li');
                li.className = 'player-item';

                let roleBadge = '';
                const roleText = gameMode === '3' ? (p.role === 1 ? 'çº¢æ–¹' : 'é»‘æ–¹') : (p.role === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹');
                if (p.role === 1) roleBadge = `<span class="badge badge-black">${roleText}</span>`;
                else if (p.role === 2) roleBadge = `<span class="badge badge-white">${roleText}</span>`;
                else roleBadge = '<span class="badge badge-viewer">è§‚ä¼—</span>';

                const hostBadge = p.isHost ? '<span class="badge badge-host">æˆ¿ä¸»</span>' : '';

                let controls = '';
                // åªæœ‰æˆ¿ä¸»èƒ½çœ‹åˆ°æ§åˆ¶æŒ‰é’®ï¼Œä¸”æ¸¸æˆæœªå¼€å§‹æ—¶æ˜¾ç¤º
                if (isHost && !isStarted) {
                    const role1Name = gameMode === '3' ? 'è®¾ä¸ºçº¢' : 'è®¾ä¸ºé»‘';
                    const role2Name = gameMode === '3' ? 'è®¾ä¸ºé»‘' : 'è®¾ä¸ºç™½';
                    controls = `
                        <div>
                            <button class="mini role-btn" onclick="setRole('${p.id}', 1)">${role1Name}</button>
                            <button class="mini role-btn" onclick="setRole('${p.id}', 2)">${role2Name}</button>
                            <button class="mini role-btn secondary" onclick="setRole('${p.id}', 0)">è®¾ä¸ºè§‚ä¼—</button>
                            ${p.id !== myId ? `<button class="kick-btn" onclick="kickPlayer('${p.id}')">è¸¢å‡º</button>` : ''}
                        </div>
                    `;
                } else if (isHost && p.id !== myId) {
                    // æ¸¸æˆè¿›è¡Œä¸­æˆ¿ä¸»ä¹Ÿå¯ä»¥è¸¢äºº
                    controls = `
                        <div>
                            <button class="kick-btn" onclick="kickPlayer('${p.id}')">è¸¢å‡º</button>
                        </div>
                    `;
                }

                li.innerHTML = `
                    <div class="player-info">
                        <strong>${p.username}</strong> ${hostBadge} ${roleBadge}
                        ${p.id === myId ? '<small>(ä½ )</small>' : ''}
                    </div>
                    ${controls}
                `;
                playerListUI.appendChild(li);
            });

            // æ›´æ–°æˆ¿ä¸»æç¤ºæ–‡å­—
            const hostHint = document.getElementById('host-hint');
            if (isHost) {
                hostHint.style.display = 'block';
                hostHint.innerText = isStarted ? 'æ¸¸æˆè¿›è¡Œä¸­ï¼Œè§’è‰²å·²é”å®š' : 'æ‚¨æ˜¯æˆ¿ä¸»ï¼Œå¯ä»¥ç‚¹å‡»ç©å®¶åˆ—è¡¨è°ƒæ•´é»‘ç™½æ£‹';
            } else {
                hostHint.style.display = 'none';
            }
        }

        function setRole(targetId, role) {
            socket.emit('setPlayerRole', { roomID: currentRoom, targetId, role });
        }

        function updateStatus() {
            if (myRole === 0) {
                statusText.innerText = 'è§‚æˆ˜ä¸­...';
                statusText.style.color = '#999';
                return;
            }
            if (currentTurn === myRole) {
                statusText.innerText = 'åˆ°ä½ äº†ï¼Œè¯·ç‚¹å‡»è½å­';
                statusText.style.color = 'var(--primary-color)';
            } else {
                let name;
                if (gameMode === '3') {
                    // è±¡æ£‹æ¨¡å¼ï¼š1ä¸ºçº¢æ–¹ï¼Œ2ä¸ºé»‘æ–¹
                    name = currentTurn === 1 ? 'çº¢æ–¹' : 'é»‘æ–¹';
                } else {
                    // å›´æ£‹/äº”å­æ£‹æ¨¡å¼ï¼š1ä¸ºé»‘æ£‹ï¼Œ2ä¸ºç™½æ£‹
                    name = currentTurn === 1 ? 'é»‘æ£‹' : 'ç™½æ£‹';
                }
                statusText.innerText = `ç­‰å¾… ${name} è½å­...`;
                statusText.style.color = '#666';
            }
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameMode === '3') {
                drawXiangqiBoard();
            } else {
                drawStandardBoard();
            }

            // ç»˜åˆ¶è¿ç é«˜äº® (äº”å­æ£‹)
            if (winLine) {
                winLine.forEach(pos => drawWinHighlight(pos.row, pos.col));
            }

            if (pendingMove) drawPiece(pendingMove.row, pendingMove.col, myRole, 0.5);
        }

        function drawStandardBoard() {
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < boardSize; i++) {
                ctx.moveTo(padding, padding + i * cellSize);
                ctx.lineTo(padding + (boardSize - 1) * cellSize, padding + i * cellSize);
                ctx.moveTo(padding + i * cellSize, padding);
                ctx.lineTo(padding + i * cellSize, padding + (boardSize - 1) * cellSize);
            }
            ctx.stroke();

            // ç»˜åˆ¶æ˜Ÿä½
            let stars = [];
            if (boardSize === 19) {
                stars = [[3, 3], [3, 9], [3, 15], [9, 3], [9, 9], [9, 15], [15, 3], [15, 9], [15, 15]];
            } else if (boardSize === 15) {
                stars = [[3, 3], [3, 7], [3, 11], [7, 3], [7, 7], [7, 11], [11, 3], [11, 7], [11, 11]];
            }

            stars.forEach(([r, c]) => {
                ctx.beginPath();
                ctx.arc(padding + c * cellSize, padding + r * cellSize, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#333';
                ctx.fill();
            });


            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (board[r] && board[r][c] !== 0) {
                        drawPiece(r, c, board[r][c], 1);
                        if (lastMove && lastMove.row === r && lastMove.col === c) {
                            drawLastMoveIndicator(r, c);
                        }
                    }
                }
            }
        }

        function drawXiangqiBoard() {
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            // æ¨ªçº¿
            for (let i = 0; i < 10; i++) {
                ctx.moveTo(padding, padding + i * cellSize);
                ctx.lineTo(padding + 8 * cellSize, padding + i * cellSize);
            }
            // çºµçº¿
            for (let i = 0; i < 9; i++) {
                ctx.moveTo(padding + i * cellSize, padding);
                if (i === 0 || i === 8) {
                    ctx.lineTo(padding + i * cellSize, padding + 9 * cellSize);
                } else {
                    ctx.lineTo(padding + i * cellSize, padding + 4 * cellSize);
                    ctx.moveTo(padding + i * cellSize, padding + 5 * cellSize);
                    ctx.lineTo(padding + i * cellSize, padding + 9 * cellSize);
                }
            }
            // ä¹å®«æ ¼
            const xLines = [[3, 0, 5, 2], [5, 0, 3, 2], [3, 7, 5, 9], [5, 7, 3, 9]];
            xLines.forEach(([c1, r1, c2, r2]) => {
                ctx.moveTo(padding + c1 * cellSize, padding + r1 * cellSize);
                ctx.lineTo(padding + c2 * cellSize, padding + r2 * cellSize);
            });
            ctx.stroke();

            // ç»˜åˆ¶æ£‹å­
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r] && board[r][c] !== 0) {
                        drawXiangqiPiece(r, c, board[r][c]);
                    }
                }
            }

            // ç»˜åˆ¶é€‰ä¸­å’Œæœ€åç§»åŠ¨æ ‡è®°
            if (selectedPiece) {
                drawHighlight(selectedPiece.row, selectedPiece.col, 'rgba(0, 255, 0, 0.5)');
            }
            if (lastMove && lastMove.fromRow !== undefined) {
                drawHighlight(lastMove.fromRow, lastMove.fromCol, 'rgba(255, 255, 0, 0.3)');
                drawHighlight(lastMove.row, lastMove.col, 'rgba(255, 255, 0, 0.3)');
            }
        }

        function drawHighlight(r, c, color) {
            ctx.fillStyle = color;
            ctx.fillRect(padding + c * cellSize - cellSize / 2, padding + r * cellSize - cellSize / 2, cellSize, cellSize);
        }

        function drawXiangqiPiece(row, col, piece) {
            const x = padding + col * cellSize;
            const y = padding + row * cellSize;
            const names = ["", "å¸…", "ä»•", "ç›¸", "é©¬", "è½¦", "ç‚®", "å…µ", "å°†", "å£«", "è±¡", "é©¬", "è½¦", "ç‚®", "å’"];

            ctx.beginPath();
            ctx.arc(x, y, cellSize * 0.42, 0, Math.PI * 2);
            ctx.fillStyle = "#f3d5a8";
            ctx.fill();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            ctx.stroke();

            // å†…éƒ¨å°åœˆ
            ctx.beginPath();
            ctx.arc(x, y, cellSize * 0.35, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = piece <= 7 ? "#e74c3c" : "#333";
            ctx.font = `bold ${cellSize * 0.55}px PingFang SC`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(names[piece], x, y);
        }

        function drawPiece(row, col, role, opacity) {
            const x = padding + col * cellSize;
            const y = padding + row * cellSize;
            const radius = cellSize * 0.42;

            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);

            const gradient = ctx.createRadialGradient(x - radius / 3, y - radius / 3, radius / 10, x, y, radius);
            if (role === 1) {
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(1, '#000');
            } else {
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ccc');
            }

            ctx.fillStyle = gradient;
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowOffsetY = 2;
            ctx.fill();
            ctx.restore();
        }

        function drawLastMoveIndicator(row, col) {
            const x = padding + col * cellSize;
            const y = padding + row * cellSize;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fillStyle = "#e74c3c";
            ctx.fill();
        }

        function drawWinHighlight(row, col) {
            const x = padding + col * cellSize;
            const y = padding + row * cellSize;
            ctx.beginPath();
            ctx.arc(x, y, cellSize * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(46, 204, 113, 0.7)";
            ctx.fill();
        }

        canvas.addEventListener('click', (e) => {
            if (currentTurn !== myRole || myRole === 0) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const col = Math.round((x - padding) / cellSize);
            const row = Math.round((y - padding) / cellSize);

            if (gameMode === '3') {
                handleXiangqiClick(row, col, e.clientX, e.clientY);
            } else {
                handleStandardClick(row, col, e.clientX, e.clientY);
            }
        });

        function handleStandardClick(row, col, clientX, clientY) {
            if (row >= 0 && row < boardSize && col >= 0 && col < boardSize && board[row][col] === 0) {
                pendingMove = { row, col };
                showConfirm(clientX, clientY);
                drawBoard();
            }
        }

        function handleXiangqiClick(row, col, clientX, clientY) {
            if (row < 0 || row >= 10 || col < 0 || col >= 9) return;

            const piece = board[row][col];
            const isMyPiece = (myRole === 1 && piece >= 1 && piece <= 7) || (myRole === 2 && piece >= 8 && piece <= 14);

            if (selectedPiece) {
                if (selectedPiece.row === row && selectedPiece.col === col) {
                    // ç‚¹å‡»å·²é€‰ä¸­çš„æ£‹å­ï¼Œå–æ¶ˆé€‰æ‹©
                    selectedPiece = null;
                } else if (isMyPiece) {
                    // ç‚¹å‡»è‡ªå·±å¦ä¸€é¢—æ£‹å­ï¼Œåˆ‡æ¢é€‰æ‹©
                    selectedPiece = { row, col };
                } else {
                    // å°è¯•ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼ˆç©ºä½æˆ–å¯¹æ–¹æ£‹å­ï¼‰
                    socket.emit('makeMove', {
                        roomID: currentRoom,
                        row: selectedPiece.row,
                        col: selectedPiece.col,
                        targetRow: row,
                        targetCol: col,
                        role: myRole
                    });
                    // ä¸ç«‹å³æ¸…ç©ºselectedPieceï¼Œç­‰æœåŠ¡å™¨è¿”å›updateBoardåè‡ªåŠ¨æ¸…ç©º
                    // è¿™æ ·å¦‚æœç§»åŠ¨å¤±è´¥ï¼Œæ£‹å­ä»ç„¶ä¿æŒé€‰ä¸­çŠ¶æ€
                }
            } else if (isMyPiece) {
                selectedPiece = { row, col };
            }
            drawBoard();
        }


        function showConfirm(clientX, clientY) {
            const rect = document.getElementById('canvas-wrapper').getBoundingClientRect();
            let left = clientX - rect.left - 60;
            let top = clientY - rect.top + 25;
            if (left < 0) left = 5;
            if (left + 120 > rect.width) left = rect.width - 125;
            if (top + 40 > rect.height) top = clientY - rect.top - 60;
            floatingConfirm.style.left = left + 'px';
            floatingConfirm.style.top = top + 'px';
            floatingConfirm.style.display = 'flex';
        }

        function hideConfirm() { floatingConfirm.style.display = 'none'; }
        function cancelMove() { pendingMove = null; hideConfirm(); drawBoard(); }
        function confirmMove() {
            if (pendingMove) {
                socket.emit('makeMove', { roomID: currentRoom, row: pendingMove.row, col: pendingMove.col, role: myRole });
                pendingMove = null; hideConfirm();
            }
        }

        function resetGame() {
            if (myRole === 0) return alert('è§‚ä¼—æ— æ³•é‡ç½®');
            if (confirm('å‘å¯¹æ–¹å‘èµ·é‡ç½®è¯·æ±‚ï¼Ÿ')) socket.emit('requestReset', currentRoom);
        }

        function undoMove() {
            if (myRole === 0) return alert('è§‚ä¼—æ— æ³•æ‚”æ£‹');
            if (!isStarted) return alert('æ¸¸æˆå°šæœªå¼€å§‹');
            if (confirm('å‘å¯¹æ–¹å‘èµ·æ‚”æ£‹è¯·æ±‚ï¼Ÿ')) socket.emit('requestUndo', currentRoom);
        }

        function passMove() {
            if (myRole === 0) return alert('è§‚ä¼—æ— æ³•æ“ä½œ');
            if (!isStarted && board.every(row => row.every(cell => cell === 0))) return alert('æ¸¸æˆå°šæœªå¼€å§‹');
            if (currentTurn !== myRole) return alert('è¿˜æ²¡è½®åˆ°ä½ ');
            socket.emit('pass', currentRoom);
        }

        function surrender() {
            if (myRole === 0) return alert('è§‚ä¼—æ— æ³•è®¤è¾“');
            if (!isStarted) return alert('æ¸¸æˆå°šæœªå¼€å§‹');
            if (confirm('ç¡®å®šè¦è®¤è¾“å—ï¼Ÿ')) {
                socket.emit('surrender', currentRoom);
            }
        }

        // åœ¨çº¿ç©å®¶é¢æ¿
        socket.on('onlinePlayers', (data) => {
            const countEl = document.getElementById('online-count');
            const listEl = document.getElementById('online-players-list');
            countEl.textContent = data.length;

            if (data.length === 0) {
                listEl.innerHTML = '<div class="online-empty">æš‚æ— åœ¨çº¿ç©å®¶</div>';
                return;
            }

            // æŒ‰æˆ¿é—´åˆ†ç»„
            const grouped = {};
            data.forEach(p => {
                if (!grouped[p.roomID]) {
                    grouped[p.roomID] = { gameModeName: p.gameModeName, gameMode: p.gameMode, players: [] };
                }
                grouped[p.roomID].players.push(p);
            });

            let html = '';
            for (const roomID in grouped) {
                const g = grouped[roomID];
                let tagClass = 'gomoku';
                if (g.gameMode === '1') tagClass = 'go';
                else if (g.gameMode === '3') tagClass = 'xiangqi';

                html += `<div class="online-room-group">`;
                html += `<div class="online-room-title">`;
                html += `<span class="game-mode-tag ${tagClass}">${g.gameModeName}</span>`;
                html += `<span>æˆ¿é—´: ${roomID}</span>`;
                html += `<button class="join-room-btn" id="join-btn-${roomID}" onclick="requestJoinRoom('${roomID}', '${g.gameMode}')">ç”³è¯·åŠ å…¥</button>`;
                html += `</div><div>`;
                g.players.forEach(p => {
                    html += `<span class="online-player-name">${p.username}</span>`;
                });
                html += `</div></div>`;
            }
            listEl.innerHTML = html;
        });

        // ç”³è¯·åŠ å…¥æˆ¿é—´
        function requestJoinRoom(roomID, roomGameMode) {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) return alert('è¯·å…ˆè¾“å…¥ç”¨æˆ·å');

            const btn = document.getElementById('join-btn-' + roomID);
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'ç­‰å¾…å®¡æ‰¹ä¸­...';
            }
            socket.emit('requestJoinRoom', { roomID, username, gameMode: roomGameMode });
        }

        // æˆ¿ä¸»æ”¶åˆ°åŠ å…¥è¯·æ±‚
        socket.on('joinRequestReceived', (data) => {
            if (confirm(`ç©å®¶ "${data.username}" ç”³è¯·åŠ å…¥æˆ¿é—´ ${data.roomID}ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ`)) {
                socket.emit('respondJoinRequest', { roomID: data.roomID, requesterId: data.requesterId, accept: true });
            } else {
                socket.emit('respondJoinRequest', { roomID: data.roomID, requesterId: data.requesterId, accept: false });
            }
        });

        // åŠ å…¥è¯·æ±‚è¢«æ‹’ç»
        socket.on('joinRequestDeclined', (data) => {
            alert(data.reason || 'åŠ å…¥è¯·æ±‚è¢«æ‹’ç»');
            // æ¢å¤æ‰€æœ‰æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.join-room-btn').forEach(btn => {
                btn.disabled = false;
                btn.textContent = 'ç”³è¯·åŠ å…¥';
            });
        });

        // è¢«æˆ¿ä¸»è¸¢å‡ºæˆ¿é—´
        socket.on('kicked', (data) => {
            alert(data.reason || 'ä½ å·²è¢«ç§»å‡ºæˆ¿é—´');
            // è¿”å›è®¾ç½®é¡µ
            currentRoom = '';
            myRole = 0;
            isHost = false;
            isStarted = false;
            document.getElementById('setup').style.display = 'block';
            document.getElementById('online-players-panel').style.display = 'block';
            document.getElementById('game-container').style.display = 'none';
        });

        // è¸¢å‡ºç©å®¶å‡½æ•°
        function kickPlayer(targetId) {
            if (confirm('ç¡®å®šè¦å°†è¯¥ç©å®¶ç§»å‡ºæˆ¿é—´å—ï¼Ÿ')) {
                socket.emit('kickPlayer', { roomID: currentRoom, targetId });
            }
        }
    </script>
</body>

</html>
